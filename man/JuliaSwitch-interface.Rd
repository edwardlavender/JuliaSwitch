% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/JuliaSwitch-interface.R
\name{JuliaSwitch-interface}
\alias{JuliaSwitch-interface}
\alias{julia_backend}
\alias{julia_start}
\alias{julia_stop}
\alias{julia_cmd_line}
\alias{julia_cmd_block}
\alias{julia_include}
\alias{julia_push}
\alias{julia_pull}
\alias{julia_using}
\alias{julia_import}
\alias{julia_pkg_activate}
\alias{julia_pkg_add}
\alias{julia_println}
\title{Julia interface}
\usage{
julia_backend(backend = c("JuliaCall", "JuliaConnectoR"))

julia_start(...)

julia_stop(...)

julia_cmd_line(...)

julia_cmd_block(...)

julia_include(file)

julia_push(name, value)

julia_pull(...)

julia_using(pkg)

julia_import(pkg)

julia_pkg_activate(s = ".")

julia_pkg_add(pkg)

julia_println(name)
}
\arguments{
\item{backend}{A \code{character} string that defines the \code{Julia} backend (\code{"JuliaCall"} or \code{"JuliaConnectoR"}).}

\item{...}{Arguments passed to \code{JuliaCall} or \code{JuliaConnectoR} routines.}

\item{file}{For \code{\link[=julia_include]{julia_include()}}, \code{file} is a \code{character} string that defines the name of a \code{Julia} script to source.}

\item{name, value}{For \code{\link[=julia_push]{julia_push()}}:
\itemize{
\item \code{name} is a \code{character} that defines the object name in \code{Julia}.
\item \code{value} is the \code{R} object.
}}

\item{pkg}{A \code{character} that defines the name of a \code{Julia} package.}

\item{s}{A \code{character} that specifies the directory of a \code{Julia} environment.}
}
\description{
A common \code{R}--\code{Julia} interface syntax.
}
\section{Interface}{
\itemize{
\item \code{\link[=julia_backend]{julia_backend()}} sets the \code{Julia} backend. This is simply a wrapper for \code{options(JuliaSwitch.backend = backend)}. The output is returned invisibly. Other functions use this option to \code{switch} between \code{JuliaCall} and \code{JuliaConnectoR} routines.
\item \code{\link[=julia_start]{julia_start()}} and \code{\link[=julia_stop]{julia_stop()}} start/stop a \code{Julia} session.
\itemize{
\item \code{\link[=julia_start]{julia_start()}} wraps \code{\link[JuliaCall:julia_setup]{JuliaCall::julia_setup()}} and \code{\link[JuliaConnectoR:startJuliaServer]{JuliaConnectoR::startJuliaServer()}}.
\item \code{\link[=julia_stop]{julia_stop()}} wraps \code{\link[=julia_terminate]{julia_terminate()}} and \code{\link[JuliaConnectoR:stopJulia]{JuliaConnectoR::stopJulia()}}, respectively. Note that \code{\link[=julia_terminate]{julia_terminate()}} is simply a placeholder that does not terminate the \code{Julia} connection.
}
\item \code{\link[=julia_cmd_line]{julia_cmd_line()}} and \code{\link[=julia_cmd_block]{julia_cmd_block()}} run lines/blocks of \code{Julia} code, provided as \code{character} strings.
\itemize{
\item \code{\link[=julia_cmd_line]{julia_cmd_line()}} wraps \code{\link[JuliaCall:julia_command]{JuliaCall::julia_command()}} or \code{\link[JuliaConnectoR:juliaEval]{JuliaConnectoR::juliaEval()}} and returns \code{invisible(NULL)}.
\item \code{\link[=julia_cmd_block]{julia_cmd_block()}} wraps \code{\link[=julia_include]{julia_include()}} and returns \code{invisible(NULL)}.
}
\item \code{\link[=julia_include]{julia_include()}} sources a \code{Julia} script.
\itemize{
\item This runs the \code{Julia} code \code{include(file)} via \code{\link[JuliaCall:julia_command]{JuliaCall::julia_command()}} or \code{\link[JuliaConnectoR:juliaEval]{JuliaConnectoR::juliaEval()}}.
}
\item \code{\link[=julia_push]{julia_push()}} and \code{\link[=julia_pull]{julia_pull()}} push/pull \code{R} objects to/from \code{Julia}.
\itemize{
\item \code{\link[=julia_push]{julia_push()}} wraps \code{\link[=julia_allot]{julia_allot()}} or \code{\link[=juliaAllot]{juliaAllot()}}. These functions expect a \code{name}--\code{value} argument pair.
\item \code{\link[=julia_pull]{julia_pull()}} wraps \code{\link[JuliaCall:julia_eval]{JuliaCall::julia_eval()}} or \code{\link[=juliaTranslate]{juliaTranslate()}}. These functions expect a \code{character} string of \code{Julia} code or the name of an \code{object} in \code{Julia} that is pulled to \code{R}.
}
}
}

\section{Helpers}{
The following helper routines are also exported:
\itemize{
\item \code{\link[=julia_using]{julia_using()}} and \code{\link[=julia_import]{julia_import()}} runs \verb{using \{pkg\}} and \verb{import \{Pkg\}}
\item \code{\link[=julia_pkg_activate]{julia_pkg_activate()}} runs \code{Pkg.activate()}
\item \code{\link[=julia_pkg_add]{julia_pkg_add()}} runs \code{Pkg.add()}
\item \code{\link[=julia_println]{julia_println()}} runs \code{println()}
}
}

\examples{
# The following suggested packages are required for these examples
library(curl)
library(terra)

# Run examples if internet is available
# This is required to install selected Julia packages (below)
if (curl::has_internet()) {

  # Define temporary Julia project
  temp <- file.path(tempdir(), "JuliaSwitch")

  # Run Julia code with each backend
  lapply(c("JuliaCall", "JuliaConnectoR"), function(backend) {

    #### Set Julia backend
    # julia_backend("JuliaCall")
    # julia_backend("JuliaConnectoR")
    julia_backend(backend)

    #### Start Julia
    # Start Julia, activate local environment & add DataFrames package
    dir.create(temp, showWarnings = FALSE)
    julia <- julia_start()
    julia_pkg_activate(temp)
    julia_pkg_add("DataFrames")
    julia_pkg_add("GeoArrays")

    #### Run one-line commands
    julia_cmd_line("x = 1")
    julia_println("x")

    #### Run larger commands
    julia_cmd_block(
      '
      x = 2
      y = 3
    '
    )
    julia_println("x")
    julia_println("y")

    #### Push objects to Julia
    # Push a matrix
    m1 <- matrix(1:4)
    julia_push("m1", m1)
    julia_println("m1")
    # Push a data.frame
    d1 <- data.frame(x = c(1, 2, 3), y = c(4, 5, 6))
    julia_push("d1", d1)
    julia_println("d1")
    # Push a SpatRaster
    r1 <- terra::rast(system.file("ex", "elev.tif",
                                  package = "terra", mustWork = TRUE))
    julia_push("r1", r1)
    julia_println("r1")

    #### Pull objects from Julia
    # Pull the matrix
    m2 <- julia_pull('m1')
    stopifnot(identical(m1, m2))
    # Pull the data.frame
    d2 <- julia_pull('d1')
    stopifnot(identical(d1, d2))

    #### Close Julia session
    julia_stop()

    # Clean up
    unlink(temp, recursive = TRUE)

  })

}
}
\author{
Edward Lavender
}
