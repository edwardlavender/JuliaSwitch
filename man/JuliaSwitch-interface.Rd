% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/JuliaSwitch.R
\name{JuliaSwitch-interface}
\alias{JuliaSwitch-interface}
\alias{julia_backend}
\alias{julia_start}
\alias{julia_stop}
\alias{julia_cmd_line}
\alias{julia_cmd_block}
\alias{julia_include}
\alias{julia_push}
\alias{julia_pull}
\title{Julia interface}
\usage{
julia_backend(backend = c("JuliaCall", "JuliaConnectoR"))

julia_start(...)

julia_stop(...)

julia_cmd_line(...)

julia_cmd_block(...)

julia_include(file)

julia_push(name, value)

julia_pull(...)
}
\arguments{
\item{backend}{A \code{character} string that defines the \code{Julia} backend (\code{"JuliaCall"} or \code{"JuliaConnectoR"}).}

\item{...}{Arguments passed to \code{JuliaCall} or \code{JuliaConnectoR} routines.}

\item{file}{For \code{\link[=julia_include]{julia_include()}}, \code{file} is a \code{character} string that defines the name of a \code{Julia} script to source.}

\item{name, value}{For \code{\link[=julia_push]{julia_push()}}:
\itemize{
\item \code{name} is a \code{character} that defines the object name in \code{Julia}.
\item \code{value} is the \code{R} object.
}}
}
\description{
A common \code{R}--\code{Julia} interface syntax.
}
\details{
\itemize{
\item \code{\link[=julia_backend]{julia_backend()}} sets the \code{Julia} backend. This is simply a wrapper for \code{options(JuliaSwitch.backend = backend)}. The output is returned invisibly. Other functions use this option to \code{switch} between \code{JuliaCall} and \code{JuliaConnectoR} routines.
\item \code{\link[=julia_start]{julia_start()}} and \code{\link[=julia_stop]{julia_stop()}} start/stop a \code{Julia} session.
\itemize{
\item \code{\link[=julia_start]{julia_start()}} wraps \code{\link[JuliaCall:julia_setup]{JuliaCall::julia_setup()}} and \code{\link[JuliaConnectoR:startJuliaServer]{JuliaConnectoR::startJuliaServer()}}.
\item \code{\link[=julia_stop]{julia_stop()}} wraps \code{\link[=julia_terminate]{julia_terminate()}} and \code{\link[JuliaConnectoR:stopJulia]{JuliaConnectoR::stopJulia()}}, respectively. Note that \code{\link[=julia_terminate]{julia_terminate()}} is simply a placeholder that does not terminate the \code{Julia} connection.
}
\item \code{\link[=julia_cmd_line]{julia_cmd_line()}} and \code{\link[=julia_cmd_block]{julia_cmd_block()}} run lines/blocks of \code{Julia} code, provided as \code{character} strings.
\itemize{
\item \code{\link[=julia_cmd_line]{julia_cmd_line()}} wraps \code{\link[JuliaCall:julia_command]{JuliaCall::julia_command()}} or \code{\link[JuliaConnectoR:juliaEval]{JuliaConnectoR::juliaEval()}} and returns \code{invisible(NULL)}.
\item \code{\link[=julia_cmd_block]{julia_cmd_block()}} wraps \code{\link[=julia_include]{julia_include()}} and returns \code{invisible(NULL)}.
}
\item \code{\link[=julia_include]{julia_include()}} sources a \code{Julia} script.
\itemize{
\item This runs the \code{Julia} code \code{include(file)} via \code{\link[JuliaCall:julia_command]{JuliaCall::julia_command()}} or \code{\link[JuliaConnectoR:juliaEval]{JuliaConnectoR::juliaEval()}}.
}
\item \code{\link[=julia_push]{julia_push()}} and \code{\link[=julia_pull]{julia_pull()}} push/pull \code{R} objects to/from \code{Julia}.
\itemize{
\item \code{\link[=julia_push]{julia_push()}} wraps \code{\link[JuliaCall:julia_assign]{JuliaCall::julia_assign()}} or \code{\link[=juliaAssign]{juliaAssign()}}. These functions expect a \code{name}--\code{value} argument pair.
\item \code{\link[=julia_pull]{julia_pull()}} wraps \code{\link[JuliaCall:julia_eval]{JuliaCall::julia_eval()}} or \code{\link[=juliaTranslate]{juliaTranslate()}}. These functions expect a \code{character} string of \code{Julia} code or the name of an \code{object} in \code{Julia} that is pulled to \code{R}.
}
}
}
\examples{
# Load packages
library(glue)

# Define temporary Julia project
temp <- file.path(tempdir(), "JuliaSwitch")
dir.create(temp)

# Run Julia code with each backend
lapply(c("JuliaCall", "JuliaConnectoR"), function(backend) {

  #### Set Julia backend
  # julia_backend("JuliaCall")
  # julia_backend("JuliaConnectoR")
  julia_backend(backend)

  #### Start Julia
  # Start Julia
  julia <- julia_start()
  # Activate local environment
  # * Add DataFrames package for DataFrames example
  julia_cmd_line('import Pkg')
  julia_cmd_line(glue('Pkg.activate("{temp}")'))
  julia_cmd_line('Pkg.add("DataFrames")')

  #### Run one-line commands
  julia_cmd_line("x = 1")
  julia_cmd_line("println(x)")

  #### Run larger commands
  julia_cmd_block(
    '
  x = 2
  y = 3
  '
  )
  julia_cmd_line("println(x)")
  julia_cmd_line("println(y)")

  #### Push objects to Julia
  # Push a matrix
  m1 <- matrix(1:4)
  julia_push("m1", m1)
  julia_cmd_line('m1')
  # Push a data.frame
  d1 <- data.frame(x = c(1, 2, 3), y = c(4, 5, 6))
  julia_push("d1", d1)
  julia_cmd_line('println(d1)')

  #### Pull objects from Julia
  # Pull the matrix
  m2 <- julia_pull('m1')
  stopifnot(identical(m1, m2))
  # Pull the data.frame
  d2 <- julia_pull('d1')
  stopifnot(identical(d1, d2))

  #### Close Julia session
  julia_stop()

  # Clean up
  unlink(temp, recursive = TRUE)

})

}
\author{
Edward Lavender
}
